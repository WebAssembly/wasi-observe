## Agenda: Jan 15 WASI Observe Video call

- **Where**: zoom.us
- **When**: Jan 15 2025, 16:00-16:30 UTC
- **Contact**:
  - Name: Caleb Schoepp

## Logistics

The meeting will be on a zoom.us video conference.

## Agenda items

1. Discuss current state of tracing proposal
  - Plans to move it to WASI OTel
  - Actual interface itself
1. *Add in agenda items here*

## Minutes

### Attendees

- [**@calebschoepp**][calebschoepp]

### Action items

- [**@{calebschoepp}**][calebschoepp], Start figuring out a new proposal for `wasi:otel`

### Notes

- wasi-observe as a Canon builtin layer after discussions with Luke and others
  - Caleb: Discussions pointed to this likely slowing us down/being a bad idea for now, but maybe later
  - Concretely this means:
    - Switch from wasi-observe to wasi-otel
    - [wasi-observe PR #15](https://github.com/WebAssembly/wasi-observe/pull/15/files) should likely be owned
  - Victor: Rename to `wasi-otel`?
    - Caleb: Could rename it, but why not garbage collect while we're here
    - Victor: Ah we could try to make a new repository?
    - Caleb: Could move us back to phase 0, why not garbage collect
    - Victor: Probably important to propose the new interface as a different proposal since we need approval anyway
  - Victor: Existing proposal with a changed internal interface?
    - Victor: this probably won't work, as the internals are going to change too much
  - Concensus: Create a new proposal
- Tracing interface discussion
  - Caleb: What we have currently mirrors the interfaces pretty well, but when using from a language, there are other concepts involved (ex. a TracerProvider)
  - Caleb: Does it make sense to more closely replicate the OTEL spec and create objects (i.e. Tracer, TracerProvider) that *then* create spans?
    - Victor: Maybe a yes? Two ideas are probably important:
      - Do we want to mirror the interface closely
      - Threaded use cases
        - Could have a default tracer that is created, but you might want a tracer per-thread
    - Caleb: Mirror is probably the most compelling reason up front
  - Victor: Some languages won't use this right?
    - Caleb: Which wouldn't use this?
    - Victor: Rust's `tracing` crate?
    - Caleb: No the Rust crate does underneath have a Tracer in use
    - Victor: Ah OK if Rust is expecting to have the Tracer then we need this?
    - Caleb: But then do we need a `TracerProvider` resource?
      - Victor: Yes this is definitely what's confusing -- it's not clear that the provider itself is present
      - Tracer is just a language level construct
    - Caleb: Start could take some tracer metadata?
    - Victor: Tracer seems like it should be present, but TracerProvider maybe not, since it's essentially just a constructor, and the provider is 
      - Cannot think of a use case 
      - Caleb: What would a custom TracerProvider even mean?
        - Victor: Delayed? Backwards spans? Filtering? 
    - Caleb: (Looking at the OTEL docs) it looks like separate configuration & span processors
    - Victor: most of the stuff should actualy happen at the language level (make a trace, make a span, etc)
    - Caleb: so we should be able to modify the language SDKs to 
    - Victor: Maybe we shouldn't have a tracer (for the same reasons of TracerProvider), it should maybe just be trace creation/modification/etc
      - Caleb: Correction, you're saying "traces" but you mean spans right?
      - Victor: Yes, I think of them as "root spans"
    - Victor: The Trace ID exists, so maybe we should have something that is a trace
      - Caleb: Trace IDs are only tracked via the SpanContext, per the spec
      - Victor: Yes, but I think it should be recommended at the WASI level, even though it's just a tag on a Root span
      - The idea of doing operations on traces or having them managed by the host *might* be necessary
    - Caleb: Could you clarify? By "trace" do you mean that it's a distinct resource from the span?
      - Victor: I'm thinking -- if the host starts the root span, how would it give it to the component?
      - Caleb: Currently the component would call `start` and if you wanted to 
      - Victor: Ah, is it in the `start-options` ?
    - Caleb: But this seems somewhat unrelated to whether we should have the Tracer or not?
      - Victor: what I'm thinking here is that `tracer` doesn't do anything you can't do with the `span` resource now. 
      - It's possible that Tracer logic should live outside just like TracerProvider logic, 
      - Maybe this is fine since we have `start-options`, and that should be in the span constructor. 
      - Implementations for tracer operations should just do WASI things.
  - Caleb: Maybe it makes more sense to try to build something around this for Go and/or Rust
    - Victor: Yes -- not sure about my availability to pair but if you can do the Go version I can do the Rust version
    - Caleb: How to generate the bindings
      - Victor: Yeah you can use the wit-bindgen tooling for that! wit-bindgen-go has changed a bunch though
    
[calebschoepp]: https://github.com/calebschoepp
